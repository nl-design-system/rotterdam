const K="rods",Q={hydratedSelectorName:"hydrated"};var X=Object.defineProperty,Z=(e,t)=>{for(var n in t)X(e,n,{get:t[n],enumerable:!0})},V="http://www.w3.org/2000/svg",ee="http://www.w3.org/1999/xhtml",M=e=>{if(e.__stencil__getHostRef)return e.__stencil__getHostRef()},te=(e,t)=>{const n={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map,$serializerValues$:new Map};n.$onReadyPromise$=new Promise(s=>n.$onReadyResolve$=s),e["s-p"]=[],e["s-rc"]=[];const r=n;return e.__stencil__getHostRef=()=>r,r},ne=(e,t)=>t in e,A=(e,t)=>(0,console.error)(e,t),S=new Map,re="slot-fb{display:contents}slot-fb[hidden]{display:none}",h=typeof window<"u"?window:{},ze=h.HTMLElement||class{},w={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,n,r)=>e.addEventListener(t,n,r),rel:(e,t,n,r)=>e.removeEventListener(t,n,r),ce:(e,t)=>new CustomEvent(e,t)},se=e=>Promise.resolve(e),L=(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})(),E=L?!!h.document&&Object.getOwnPropertyDescriptor(h.document.adoptedStyleSheets,"length").writable:!1,k=!1,j=[],q=[],oe=(e,t)=>n=>{e.push(n),k||(k=!0,w.raf(W))},O=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(n){A(n)}e.length=0},W=()=>{O(j),O(q),(k=j.length>0)&&w.raf(W)},D=e=>se().then(e),le=oe(q),B=e=>(e=typeof e,e==="object"||e==="function");function ae(e){var t,n,r;return(r=(n=(t=e.head)==null?void 0:t.querySelector('meta[name="csp-nonce"]'))==null?void 0:n.getAttribute("content"))!=null?r:void 0}var ie=e=>e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),ce={};Z(ce,{err:()=>z,map:()=>de,ok:()=>_,unwrap:()=>$e,unwrapErr:()=>fe});var _=e=>({isOk:!0,isErr:!1,value:e}),z=e=>({isOk:!1,isErr:!0,value:e});function de(e,t){if(e.isOk){const n=t(e.value);return n instanceof Promise?n.then(r=>_(r)):_(n)}if(e.isErr){const n=e.value;return z(n)}throw"should never get here"}var $e=e=>{if(e.isOk)return e.value;throw e.value},fe=e=>{if(e.isErr)return e.value;throw e.value};var y;function pe(e){var t;const n=this.attachShadow({mode:"open"});y===void 0&&(y=(t=void 0)!=null?t:null),y&&(E?n.adoptedStyleSheets.push(y):n.adoptedStyleSheets=[...n.adoptedStyleSheets,y])}var v=(e,t="")=>()=>{},g=new WeakMap,ue=(e,t,n)=>{let r=S.get(e);L&&n?(r=r||new CSSStyleSheet,typeof r=="string"?r=t:r.replaceSync(t)):r=t,S.set(e,r)},he=(e,t,n)=>{var r;const s=N(t),o=S.get(s);if(!h.document)return s;if(e=e.nodeType===11?e:h.document,o)if(typeof o=="string"){e=e.head||e;let a=g.get(e),l;if(a||g.set(e,a=new Set),!a.has(s)){{l=h.document.createElement("style"),l.innerHTML=o;const c=(r=w.$nonce$)!=null?r:ae(h.document);if(c!=null&&l.setAttribute("nonce",c),!(t.$flags$&1))if(e.nodeName==="HEAD"){const i=e.querySelectorAll("link[rel=preconnect]"),d=i.length>0?i[i.length-1].nextSibling:e.querySelector("style");e.insertBefore(l,d?.parentNode===e?d:null)}else if("host"in e)if(L){const i=new CSSStyleSheet;i.replaceSync(o),E?e.adoptedStyleSheets.unshift(i):e.adoptedStyleSheets=[i,...e.adoptedStyleSheets]}else{const i=e.querySelector("style");i?i.innerHTML=o+i.innerHTML:e.prepend(l)}else e.append(l);t.$flags$&1&&e.insertBefore(l,null)}t.$flags$&4&&(l.innerHTML+=re),a&&a.add(s)}}else e.adoptedStyleSheets.includes(o)||(E?e.adoptedStyleSheets.push(o):e.adoptedStyleSheets=[...e.adoptedStyleSheets,o]);return s},ve=e=>{const t=e.$cmpMeta$,n=e.$hostElement$,r=t.$flags$,s=v("attachStyles",t.$tagName$),o=he(n.shadowRoot?n.shadowRoot:n.getRootNode(),t);r&10&&(n["s-sc"]=o,n.classList.add(o+"-h")),s()},N=(e,t)=>"sc-"+e.$tagName$,ge=(e,t,...n)=>{let r=null,s=null,o=!1,a=!1;const l=[],c=d=>{for(let f=0;f<d.length;f++)r=d[f],Array.isArray(r)?c(r):r!=null&&typeof r!="boolean"&&((o=typeof e!="function"&&!B(r))&&(r=String(r)),o&&a?l[l.length-1].$text$+=r:l.push(o?b(null,r):r),a=o)};if(c(n),t){t.key&&(s=t.key);{const d=t.className||t.class;d&&(t.class=typeof d!="object"?d:Object.keys(d).filter(f=>d[f]).join(" "))}}const i=b(e,null);return i.$attrs$=t,l.length>0&&(i.$children$=l),i.$key$=s,i},b=(e,t)=>{const n={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return n.$attrs$=null,n.$key$=null,n},me={},ye=e=>e&&e.$tag$===me,H=e=>{const t=ie(e);return new RegExp(`(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${t}))(${t}\\b)`,"g")};H("::slotted");H(":host");H(":host-context");var Se=(e,t,n)=>{const r=w.ce(t,n);return e.dispatchEvent(r),r},we=(e,t,n,r,s,o,a)=>{if(n===r)return;let l=ne(e,t);if(t.toLowerCase(),t==="class"){const c=e.classList,i=T(n);let d=T(r);c.remove(...i.filter(f=>f&&!d.includes(f))),c.add(...d.filter(f=>f&&!i.includes(f)))}else if(t!=="key"){const c=B(r);if((l||c&&r!==null)&&!s)try{if(e.tagName.includes("-"))e[t]!==r&&(e[t]=r);else{const i=r??"";t==="list"?l=!1:(n==null||e[t]!=i)&&(typeof e.__lookupSetter__(t)=="function"?e[t]=i:e.setAttribute(t,i))}}catch{}r==null||r===!1?(r!==!1||e.getAttribute(t)==="")&&e.removeAttribute(t):(!l||o&4||s)&&!c&&e.nodeType===1&&(r=r===!0?"":r,e.setAttribute(t,r))}},Ee=/\s/,T=e=>(typeof e=="object"&&e&&"baseVal"in e&&(e=e.baseVal),!e||typeof e!="string"?[]:e.split(Ee)),I=(e,t,n,r)=>{const s=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,o=e&&e.$attrs$||{},a=t.$attrs$||{};for(const l of ke(Object.keys(a)))we(s,l,o[l],a[l],n,t.$flags$)};function ke(e){return e.includes("ref")?[...e.filter(t=>t!=="ref"),"ref"]:e}var R,p=!1,F=(e,t,n)=>{const r=t.$children$[n];let s=0,o,a;{if(p||(p=r.$tag$==="svg"),!h.document)throw new Error("You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.");if(o=r.$elm$=h.document.createElementNS(p?V:ee,r.$tag$),p&&r.$tag$==="foreignObject"&&(p=!1),I(null,r,p),r.$children$)for(s=0;s<r.$children$.length;++s)a=F(e,r,s),a&&o.appendChild(a);r.$tag$==="svg"?p=!1:o.tagName==="foreignObject"&&(p=!0)}return o["s-hn"]=R,o},_e=(e,t,n,r,s,o)=>{let a=e,l;for(a.shadowRoot&&a.tagName===R&&(a=a.shadowRoot);s<=o;++s)r[s]&&(l=F(null,n,s),l&&(r[s].$elm$=l,Me(a,l,t)))},be=(e,t,n=!1)=>{const r=t.$elm$=e.$elm$,s=t.$children$,o=t.$tag$;p=o==="svg"?!0:o==="foreignObject"?!1:p,I(e,t,p),s!==null&&_e(r,null,t,s,0,s.length-1),p&&o==="svg"&&(p=!1)},Me=(e,t,n)=>e?.insertBefore(t,n),Ae=(e,t,n=!1)=>{const r=e.$hostElement$,s=e.$vnode$||b(null,null),a=ye(t)?t:ge(null,null,t);if(R=r.tagName,n&&a.$attrs$)for(const l of Object.keys(a.$attrs$))r.hasAttribute(l)&&!["key","ref","style","class"].includes(l)&&(a.$attrs$[l]=r[l]);a.$tag$=null,a.$flags$|=4,e.$vnode$=a,a.$elm$=s.$elm$=r.shadowRoot||r,be(s,a,n)},G=(e,t)=>{if(t&&!e.$onRenderResolve$&&t["s-p"]){const n=t["s-p"].push(new Promise(r=>e.$onRenderResolve$=()=>{t["s-p"].splice(n-1,1),r()}))}},Y=(e,t)=>{if(e.$flags$&4){e.$flags$|=512;return}G(e,e.$ancestorComponent$);const n=()=>Le(e,t);if(t){queueMicrotask(()=>{n()});return}return le(n)},Le=(e,t)=>{const n=e.$hostElement$,r=v("scheduleUpdate",e.$cmpMeta$.$tagName$),s=n;if(!s)throw new Error(`Can't render component <${n.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);let o;return t?o=m(s,"componentWillLoad",void 0,n):o=m(s,"componentWillUpdate",void 0,n),o=P(o,()=>m(s,"componentWillRender",void 0,n)),r(),P(o,()=>Re(e,s,t))},P=(e,t)=>He(e)?e.then(t).catch(n=>{console.error(n),t()}):t(),He=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",Re=async(e,t,n)=>{var r;const s=e.$hostElement$,o=v("update",e.$cmpMeta$.$tagName$),a=s["s-rc"];n&&ve(e);const l=v("render",e.$cmpMeta$.$tagName$);Ce(e,t,s,n),a&&(a.map(c=>c()),s["s-rc"]=void 0),l(),o();{const c=(r=s["s-p"])!=null?r:[],i=()=>je(e);c.length===0?i():(Promise.all(c).then(i),e.$flags$|=4,c.length=0)}},Ce=(e,t,n,r)=>{try{t=t.render(),Ae(e,t,r)}catch(s){A(s,e.$hostElement$)}return null},je=e=>{const t=e.$cmpMeta$.$tagName$,n=e.$hostElement$,r=v("postUpdate",t),s=n,o=e.$ancestorComponent$;m(s,"componentDidRender",void 0,n),e.$flags$&64?(m(s,"componentDidUpdate",void 0,n),r()):(e.$flags$|=64,Te(n),m(s,"componentDidLoad",void 0,n),r(),e.$onReadyResolve$(n),o||Oe()),e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&D(()=>Y(e,!1)),e.$flags$&=-517},Oe=e=>{D(()=>Se(h,"appload",{detail:{namespace:K}}))},m=(e,t,n,r)=>{if(e&&e[t])try{return e[t](n)}catch(s){A(s,r)}},Te=e=>{var t;return e.classList.add((t=Q.hydratedSelectorName)!=null?t:"hydrated")},Pe=(e,t,n)=>e,xe=async(e,t,n,r)=>{let s;if((t.$flags$&32)===0){t.$flags$|=32;{s=e.constructor;const l=e.localName;customElements.whenDefined(l).then(()=>t.$flags$|=128)}if(s&&s.style){let l;typeof s.style=="string"&&(l=s.style);const c=N(n);if(!S.has(c)){const i=v("registerStyles",n.$tagName$);ue(c,l,!!(n.$flags$&1)),i()}}}const o=t.$ancestorComponent$,a=()=>Y(t,!0);o&&o["s-rc"]?o["s-rc"].push(a):a()},Ue=(e,t)=>{},qe=e=>{{const t=M(e);if(!t)return;const n=t.$cmpMeta$,r=v("connectedCallback",n.$tagName$);if(t.$flags$&1)t?.$lazyInstance$||t?.$onReadyPromise$&&t.$onReadyPromise$.then(()=>Ue());else{t.$flags$|=1;{let s=e;for(;s=s.parentNode||s.host;)if(s["s-p"]){G(t,t.$ancestorComponent$=s);break}}xe(e,t,n)}r()}},We=async e=>{M(e),g.has(e)&&g.delete(e),e.shadowRoot&&g.has(e.shadowRoot)&&g.delete(e.shadowRoot)},Ne=(e,t)=>{const n={$flags$:t[0],$tagName$:t[1]},r=e.prototype.connectedCallback,s=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__hasHostListenerAttached:!1,__registerHost(){te(this,n)},connectedCallback(){if(!this.__hasHostListenerAttached){if(!M(this))return;this.__hasHostListenerAttached=!0}qe(this),r&&r.call(this)},disconnectedCallback(){We(this),s&&s.call(this)},__attachShadow(){if(!this.shadowRoot)pe.call(this,n);else if(this.shadowRoot.mode!=="open")throw new Error(`Unable to re-use existing shadow root for ${n.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`)}}),e.is=n.$tagName$,Pe(e)};const De=new Set(["children","localName","ref","style","className"]),x=new WeakMap,U=(e,t,n,r,s)=>{const o=s?.[t];o===void 0?(e[t]=n,n==null&&t in HTMLElement.prototype&&e.removeAttribute(t)):n!==r&&((a,l,c)=>{let i=x.get(a);i===void 0&&x.set(a,i=new Map);let d=i.get(l);c!==void 0?d===void 0?(i.set(l,d={handleEvent:c}),a.addEventListener(l,d)):d.handleEvent=c:d!==void 0&&(i.delete(l),a.removeEventListener(l,d))})(e,o,n)},Be=({react:e,tagName:t,elementClass:n,events:r,displayName:s})=>{const o=new Set(Object.keys(r??{})),a=e.forwardRef((l,c)=>{const i=e.useRef(new Map),d=e.useRef(null),f={},C={};for(const[$,u]of Object.entries(l))De.has($)?f[$==="className"?"class":$]=u:o.has($)||$ in n.prototype?C[$]=u:f[$]=u;return e.useLayoutEffect(()=>{if(d.current===null)return;const $=new Map;for(const u in C)U(d.current,u,l[u],i.current.get(u),r),i.current.delete(u),$.set(u,l[u]);for(const[u,J]of i.current)U(d.current,u,void 0,J,r);i.current=$}),e.useLayoutEffect(()=>{var $;($=d.current)==null||$.removeAttribute("defer-hydration")},[]),f.suppressHydrationWarning=!0,e.createElement(t,{...f,ref:e.useCallback($=>{d.current=$,typeof c=="function"?c($):c!==null&&(c.current=$)},[c])})});return a.displayName=s??n.name,a},Ie=({defineCustomElement:e,...t})=>(typeof e<"u"&&e(),Be(t));export{Ie as E,ze as H,ge as h,Ne as p};
