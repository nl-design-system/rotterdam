const X="rods",D={hydratedSelectorName:"hydrated"};var Z=Object.defineProperty,V=(e,t)=>{for(var n in t)Z(e,n,{get:t[n],enumerable:!0})},ee="http://www.w3.org/2000/svg",te="http://www.w3.org/1999/xhtml",M=e=>{if(e.__stencil__getHostRef)return e.__stencil__getHostRef()},ne=(e,t)=>{const n={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};n.$onReadyPromise$=new Promise(s=>n.$onReadyResolve$=s),e["s-p"]=[],e["s-rc"]=[];const r=n;return e.__stencil__getHostRef=()=>r,r},re=(e,t)=>t in e,A=(e,t)=>(0,console.error)(e,t),S=new Map,se="slot-fb{display:contents}slot-fb[hidden]{display:none}",h=typeof window<"u"?window:{},Ne=h.HTMLElement||class{},w={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,n,r)=>e.addEventListener(t,n,r),rel:(e,t,n,r)=>e.removeEventListener(t,n,r),ce:(e,t)=>new CustomEvent(e,t)},oe=e=>Promise.resolve(e),L=(()=>{try{return new CSSStyleSheet,typeof new CSSStyleSheet().replaceSync=="function"}catch{}return!1})(),E=L?!!h.document&&Object.getOwnPropertyDescriptor(h.document.adoptedStyleSheets,"length").writable:!1,k=!1,j=[],B=[],le=(e,t)=>n=>{e.push(n),k||(k=!0,w.raf(N))},O=e=>{for(let t=0;t<e.length;t++)try{e[t](performance.now())}catch(n){A(n)}e.length=0},N=()=>{O(j),O(B),(k=j.length>0)&&w.raf(N)},H=e=>oe().then(e),ae=le(B),z=e=>(e=typeof e,e==="object"||e==="function");function ie(e){var t,n,r;return(r=(n=(t=e.head)==null?void 0:t.querySelector('meta[name="csp-nonce"]'))==null?void 0:n.getAttribute("content"))!=null?r:void 0}var ce=e=>e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),de={};V(de,{err:()=>I,map:()=>$e,ok:()=>_,unwrap:()=>fe,unwrapErr:()=>pe});var _=e=>({isOk:!0,isErr:!1,value:e}),I=e=>({isOk:!1,isErr:!0,value:e});function $e(e,t){if(e.isOk){const n=t(e.value);return n instanceof Promise?n.then(r=>_(r)):_(n)}if(e.isErr){const n=e.value;return I(n)}throw"should never get here"}var fe=e=>{if(e.isOk)return e.value;throw e.value},pe=e=>{if(e.isErr)return e.value;throw e.value};var y;function ue(e){var t;const n=this.attachShadow({mode:"open"});y===void 0&&(y=(t=void 0)!=null?t:null),y&&(E?n.adoptedStyleSheets.push(y):n.adoptedStyleSheets=[...n.adoptedStyleSheets,y])}var v=(e,t="")=>()=>{},g=new WeakMap,he=(e,t,n)=>{let r=S.get(e);L&&n?(r=r||new CSSStyleSheet,typeof r=="string"?r=t:r.replaceSync(t)):r=t,S.set(e,r)},ve=(e,t,n)=>{var r;const s=F(t),o=S.get(s);if(!h.document)return s;if(e=e.nodeType===11?e:h.document,o)if(typeof o=="string"){e=e.head||e;let a=g.get(e),l;if(a||g.set(e,a=new Set),!a.has(s)){{l=h.document.createElement("style"),l.innerHTML=o;const c=(r=w.$nonce$)!=null?r:ie(h.document);if(c!=null&&l.setAttribute("nonce",c),!(t.$flags$&1))if(e.nodeName==="HEAD"){const i=e.querySelectorAll("link[rel=preconnect]"),d=i.length>0?i[i.length-1].nextSibling:e.querySelector("style");e.insertBefore(l,(d==null?void 0:d.parentNode)===e?d:null)}else if("host"in e)if(L){const i=new CSSStyleSheet;i.replaceSync(o),E?e.adoptedStyleSheets.unshift(i):e.adoptedStyleSheets=[i,...e.adoptedStyleSheets]}else{const i=e.querySelector("style");i?i.innerHTML=o+i.innerHTML:e.prepend(l)}else e.append(l);t.$flags$&1&&e.insertBefore(l,null)}t.$flags$&4&&(l.innerHTML+=se),a&&a.add(s)}}else e.adoptedStyleSheets.includes(o)||(E?e.adoptedStyleSheets.push(o):e.adoptedStyleSheets=[...e.adoptedStyleSheets,o]);return s},ge=e=>{const t=e.$cmpMeta$,n=e.$hostElement$,r=t.$flags$,s=v("attachStyles",t.$tagName$),o=ve(n.shadowRoot?n.shadowRoot:n.getRootNode(),t);r&10&&(n["s-sc"]=o,n.classList.add(o+"-h")),s()},F=(e,t)=>"sc-"+e.$tagName$,me=(e,t,...n)=>{let r=null,s=null,o=!1,a=!1;const l=[],c=d=>{for(let f=0;f<d.length;f++)r=d[f],Array.isArray(r)?c(r):r!=null&&typeof r!="boolean"&&((o=typeof e!="function"&&!z(r))&&(r=String(r)),o&&a?l[l.length-1].$text$+=r:l.push(o?b(null,r):r),a=o)};if(c(n),t){t.key&&(s=t.key);{const d=t.className||t.class;d&&(t.class=typeof d!="object"?d:Object.keys(d).filter(f=>d[f]).join(" "))}}const i=b(e,null);return i.$attrs$=t,l.length>0&&(i.$children$=l),i.$key$=s,i},b=(e,t)=>{const n={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return n.$attrs$=null,n.$key$=null,n},ye={},Se=e=>e&&e.$tag$===ye,R=e=>{const t=ce(e);return new RegExp(`(^|[^@]|@(?!supports\\s+selector\\s*\\([^{]*?${t}))(${t}\\b)`,"g")};R("::slotted");R(":host");R(":host-context");var we=(e,t,n)=>{const r=w.ce(t,n);return e.dispatchEvent(r),r},Ee=(e,t,n,r,s,o,a)=>{if(n===r)return;let l=re(e,t);if(t.toLowerCase(),t==="class"){const c=e.classList,i=x(n);let d=x(r);c.remove(...i.filter(f=>f&&!d.includes(f))),c.add(...d.filter(f=>f&&!i.includes(f)))}else if(t!=="key"){const c=z(r);if((l||c&&r!==null)&&!s)try{if(e.tagName.includes("-"))e[t]!==r&&(e[t]=r);else{const i=r??"";t==="list"?l=!1:(n==null||e[t]!=i)&&(typeof e.__lookupSetter__(t)=="function"?e[t]=i:e.setAttribute(t,i))}}catch{}r==null||r===!1?(r!==!1||e.getAttribute(t)==="")&&e.removeAttribute(t):(!l||o&4||s)&&!c&&e.nodeType===1&&(r=r===!0?"":r,e.setAttribute(t,r))}},ke=/\s/,x=e=>(typeof e=="object"&&e&&"baseVal"in e&&(e=e.baseVal),!e||typeof e!="string"?[]:e.split(ke)),G=(e,t,n,r)=>{const s=t.$elm$.nodeType===11&&t.$elm$.host?t.$elm$.host:t.$elm$,o=e&&e.$attrs$||{},a=t.$attrs$||{};for(const l of _e(Object.keys(a)))Ee(s,l,o[l],a[l],n,t.$flags$)};function _e(e){return e.includes("ref")?[...e.filter(t=>t!=="ref"),"ref"]:e}var C,p=!1,Y=(e,t,n)=>{const r=t.$children$[n];let s=0,o,a;{if(p||(p=r.$tag$==="svg"),!h.document)throw new Error("You are trying to render a Stencil component in an environment that doesn't support the DOM. Make sure to populate the [`window`](https://developer.mozilla.org/en-US/docs/Web/API/Window/window) object before rendering a component.");if(o=r.$elm$=h.document.createElementNS(p?ee:te,r.$tag$),p&&r.$tag$==="foreignObject"&&(p=!1),G(null,r,p),r.$children$)for(s=0;s<r.$children$.length;++s)a=Y(e,r,s),a&&o.appendChild(a);r.$tag$==="svg"?p=!1:o.tagName==="foreignObject"&&(p=!0)}return o["s-hn"]=C,o},be=(e,t,n,r,s,o)=>{let a=e,l;for(a.shadowRoot&&a.tagName===C&&(a=a.shadowRoot);s<=o;++s)r[s]&&(l=Y(null,n,s),l&&(r[s].$elm$=l,Ae(a,l,t)))},Me=(e,t,n=!1)=>{const r=t.$elm$=e.$elm$,s=t.$children$,o=t.$tag$;p=o==="svg"?!0:o==="foreignObject"?!1:p,G(e,t,p),s!==null&&be(r,null,t,s,0,s.length-1),p&&o==="svg"&&(p=!1)},Ae=(e,t,n)=>e==null?void 0:e.insertBefore(t,n),Le=(e,t,n=!1)=>{const r=e.$hostElement$,s=e.$vnode$||b(null,null),a=Se(t)?t:me(null,null,t);if(C=r.tagName,n&&a.$attrs$)for(const l of Object.keys(a.$attrs$))r.hasAttribute(l)&&!["key","ref","style","class"].includes(l)&&(a.$attrs$[l]=r[l]);a.$tag$=null,a.$flags$|=4,e.$vnode$=a,a.$elm$=s.$elm$=r.shadowRoot||r,Me(s,a,n)},J=(e,t)=>{if(t&&!e.$onRenderResolve$&&t["s-p"]){const n=t["s-p"].push(new Promise(r=>e.$onRenderResolve$=()=>{t["s-p"].splice(n-1,1),r()}))}},K=(e,t)=>{if(e.$flags$&4){e.$flags$|=512;return}J(e,e.$ancestorComponent$);const n=()=>He(e,t);if(t){queueMicrotask(()=>{n()});return}return ae(n)},He=(e,t)=>{const n=e.$hostElement$,r=v("scheduleUpdate",e.$cmpMeta$.$tagName$),s=n;if(!s)throw new Error(`Can't render component <${n.tagName.toLowerCase()} /> with invalid Stencil runtime! Make sure this imported component is compiled with a \`externalRuntime: true\` flag. For more information, please refer to https://stenciljs.com/docs/custom-elements#externalruntime`);let o;return t?o=m(s,"componentWillLoad",void 0,n):o=m(s,"componentWillUpdate",void 0,n),o=P(o,()=>m(s,"componentWillRender",void 0,n)),r(),P(o,()=>Ce(e,s,t))},P=(e,t)=>Re(e)?e.then(t).catch(n=>{console.error(n),t()}):t(),Re=e=>e instanceof Promise||e&&e.then&&typeof e.then=="function",Ce=async(e,t,n)=>{var r;const s=e.$hostElement$,o=v("update",e.$cmpMeta$.$tagName$),a=s["s-rc"];n&&ge(e);const l=v("render",e.$cmpMeta$.$tagName$);Te(e,t,s,n),a&&(a.map(c=>c()),s["s-rc"]=void 0),l(),o();{const c=(r=s["s-p"])!=null?r:[],i=()=>je(e);c.length===0?i():(Promise.all(c).then(i),e.$flags$|=4,c.length=0)}},Te=(e,t,n,r)=>{try{t=t.render(),Le(e,t,r)}catch(s){A(s,e.$hostElement$)}return null},je=e=>{const t=e.$cmpMeta$.$tagName$,n=e.$hostElement$,r=v("postUpdate",t),s=n,o=e.$ancestorComponent$;m(s,"componentDidRender",void 0,n),e.$flags$&64?(m(s,"componentDidUpdate",void 0,n),r()):(e.$flags$|=64,xe(n),m(s,"componentDidLoad",void 0,n),r(),e.$onReadyResolve$(n),o||Oe()),e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),e.$flags$&512&&H(()=>K(e,!1)),e.$flags$&=-517},Oe=e=>{H(()=>we(h,"appload",{detail:{namespace:X}}))},m=(e,t,n,r)=>{if(e&&e[t])try{return e[t](n)}catch(s){A(s,r)}},xe=e=>{var t;return e.classList.add((t=D.hydratedSelectorName)!=null?t:"hydrated")},Pe=(e,t,n)=>e,U=async(e,t,n,r)=>{let s;if(!(t.$flags$&32)){t.$flags$|=32;{s=e.constructor;const l=e.localName;customElements.whenDefined(l).then(()=>t.$flags$|=128)}if(s&&s.style){let l;typeof s.style=="string"&&(l=s.style);const c=F(n);if(!S.has(c)){const i=v("registerStyles",n.$tagName$);he(c,l,!!(n.$flags$&1)),i()}}}const o=t.$ancestorComponent$,a=()=>K(t,!0);o&&o["s-rc"]?o["s-rc"].push(a):a()},Ue=(e,t)=>{},qe=e=>{{const t=M(e);if(!t)return;const n=t.$cmpMeta$,r=v("connectedCallback",n.$tagName$);if(t.$flags$&1)t!=null&&t.$lazyInstance$||t!=null&&t.$onReadyPromise$&&t.$onReadyPromise$.then(()=>Ue());else{t.$flags$|=1;{let s=e;for(;s=s.parentNode||s.host;)if(s["s-p"]){J(t,t.$ancestorComponent$=s);break}}D.initializeNextTick?H(()=>U(e,t,n)):U(e,t,n)}r()}},We=async e=>{M(e),g.has(e)&&g.delete(e),e.shadowRoot&&g.has(e.shadowRoot)&&g.delete(e.shadowRoot)},ze=(e,t)=>{const n={$flags$:t[0],$tagName$:t[1]},r=e.prototype.connectedCallback,s=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__hasHostListenerAttached:!1,__registerHost(){ne(this,n)},connectedCallback(){if(!this.__hasHostListenerAttached){if(!M(this))return;this.__hasHostListenerAttached=!0}qe(this),r&&r.call(this)},disconnectedCallback(){We(this),s&&s.call(this)},__attachShadow(){if(!this.shadowRoot)ue.call(this,n);else if(this.shadowRoot.mode!=="open")throw new Error(`Unable to re-use existing shadow root for ${n.$tagName$}! Mode is set to ${this.shadowRoot.mode} but Stencil only supports open shadow roots.`)}}),e.is=n.$tagName$,Pe(e)};const De=new Set(["children","localName","ref","style","className"]),q=new WeakMap,W=(e,t,n,r,s)=>{const o=s==null?void 0:s[t];o===void 0?(e[t]=n,n==null&&t in HTMLElement.prototype&&e.removeAttribute(t)):n!==r&&((a,l,c)=>{let i=q.get(a);i===void 0&&q.set(a,i=new Map);let d=i.get(l);c!==void 0?d===void 0?(i.set(l,d={handleEvent:c}),a.addEventListener(l,d)):d.handleEvent=c:d!==void 0&&(i.delete(l),a.removeEventListener(l,d))})(e,o,n)},Be=({react:e,tagName:t,elementClass:n,events:r,displayName:s})=>{const o=new Set(Object.keys(r??{})),a=e.forwardRef((l,c)=>{const i=e.useRef(new Map),d=e.useRef(null),f={},T={};for(const[$,u]of Object.entries(l))De.has($)?f[$==="className"?"class":$]=u:o.has($)||$ in n.prototype?T[$]=u:f[$]=u;return e.useLayoutEffect(()=>{if(d.current===null)return;const $=new Map;for(const u in T)W(d.current,u,l[u],i.current.get(u),r),i.current.delete(u),$.set(u,l[u]);for(const[u,Q]of i.current)W(d.current,u,void 0,Q,r);i.current=$}),e.useLayoutEffect(()=>{var $;($=d.current)==null||$.removeAttribute("defer-hydration")},[]),f.suppressHydrationWarning=!0,e.createElement(t,{...f,ref:e.useCallback($=>{d.current=$,typeof c=="function"?c($):c!==null&&(c.current=$)},[c])})});return a.displayName=s??n.name,a},Ie=({defineCustomElement:e,...t})=>(typeof e<"u"&&e(),Be(t));export{Ie as E,Ne as H,me as h,ze as p};
